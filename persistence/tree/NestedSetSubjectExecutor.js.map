{"version":3,"sources":["../../src/persistence/tree/NestedSetSubjectExecutor.ts"],"names":[],"mappings":"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","file":"NestedSetSubjectExecutor.js","sourcesContent":["import {Subject} from \"../Subject\";\r\nimport {QueryRunner} from \"../../query-runner/QueryRunner\";\r\nimport {OrmUtils} from \"../../util/OrmUtils\";\r\nimport {NestedSetMultipleRootError} from \"../../error/NestedSetMultipleRootError\";\r\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\r\nimport {EntityMetadata} from \"../../metadata/EntityMetadata\";\r\n\r\nclass NestedSetIds {\r\n    left: number;\r\n    right: number;\r\n}\r\n\r\n/**\r\n * Executes subject operations for nested set tree entities.\r\n */\r\nexport class NestedSetSubjectExecutor {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected queryRunner: QueryRunner) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Executes operations when subject is being inserted.\r\n     */\r\n    async insert(subject: Subject): Promise<void> {\r\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\r\n        const tableName = this.getTableName(subject.metadata.tablePath);\r\n        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn!.databaseName);\r\n        const rightColumnName = escape(subject.metadata.nestedSetRightColumn!.databaseName);\r\n\r\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\r\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\r\n            parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\r\n        const parentId = subject.metadata.getEntityIdMap(parent);\r\n\r\n        let parentNsRight: number|undefined = undefined;\r\n        if (parentId) {\r\n            parentNsRight = await this.queryRunner.manager\r\n                .createQueryBuilder()\r\n                .select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn!.propertyPath, \"right\")\r\n                .from(subject.metadata.target, subject.metadata.targetName)\r\n                .whereInIds(parentId)\r\n                .getRawOne()\r\n                .then(result => {\r\n                    const value: any = result ? result[\"right\"] : undefined;\r\n                    // CockroachDB returns numeric types as string\r\n                    return typeof value === \"string\" ? parseInt(value) : value;\r\n                });\r\n        }\r\n\r\n        if (parentNsRight !== undefined) {\r\n            await this.queryRunner.query(`UPDATE ${tableName} SET ` +\r\n                `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\r\n                `${rightColumnName} = ${rightColumnName} + 2 ` +\r\n                `WHERE ${rightColumnName} >= ${parentNsRight}`);\r\n\r\n            OrmUtils.mergeDeep(\r\n                subject.insertedValueSet,\r\n                subject.metadata.nestedSetLeftColumn!.createValueMap(parentNsRight),\r\n                subject.metadata.nestedSetRightColumn!.createValueMap(parentNsRight + 1),\r\n            );\r\n        } else {\r\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\r\n\r\n            // Validate if a root entity already exits and throw an exception\r\n            if (!isUniqueRoot)\r\n                throw new NestedSetMultipleRootError();\r\n\r\n            OrmUtils.mergeDeep(\r\n                subject.insertedValueSet,\r\n                subject.metadata.nestedSetLeftColumn!.createValueMap(1),\r\n                subject.metadata.nestedSetRightColumn!.createValueMap(2),\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executes operations when subject is being updated.\r\n     */\r\n    async update(subject: Subject): Promise<void> {\r\n        let parent = subject.metadata.treeParentRelation!.getEntityValue(subject.entity!); // if entity was attached via parent\r\n        if (!parent && subject.parentSubject && subject.parentSubject.entity) // if entity was attached via children\r\n            parent = subject.parentSubject.entity;\r\n\r\n        let entity = subject.databaseEntity; // if entity was attached via parent\r\n        if (!entity && parent) // if entity was attached via children\r\n            entity = subject.metadata.treeChildrenRelation!.getEntityValue(parent).find((child: any) => {\r\n                return Object.entries(subject.identifier!).every(([key, value]) => child[key] === value);\r\n            });\r\n\r\n        // Exit if the parent or the entity where never set\r\n        if (entity === undefined || parent === undefined) {\r\n            return;\r\n        }\r\n\r\n\r\n        const oldParent = subject.metadata.treeParentRelation!.getEntityValue(entity!);\r\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\r\n        const parentId = subject.metadata.getEntityIdMap(parent);\r\n\r\n        // Exit if the new and old parents are the same\r\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\r\n            return;\r\n        }\r\n\r\n        if (parent) {\r\n            const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\r\n            const tableName = this.getTableName(subject.metadata.tablePath);\r\n            const leftColumnName = escape(subject.metadata.nestedSetLeftColumn!.databaseName);\r\n            const rightColumnName = escape(subject.metadata.nestedSetRightColumn!.databaseName);\r\n\r\n            const entityId = subject.metadata.getEntityIdMap(entity);\r\n\r\n            let entityNs: NestedSetIds | undefined = undefined;\r\n            if (entityId) {\r\n                entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];\r\n            }\r\n\r\n            let parentNs: NestedSetIds | undefined = undefined;\r\n            if (parentId) {\r\n                parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];\r\n            }\r\n\r\n            if (entityNs !== undefined && parentNs !== undefined) {\r\n                const isMovingUp = parentNs.left > entityNs.left;\r\n                const treeSize = entityNs.right - entityNs.left + 1;\r\n\r\n                let entitySize: number;\r\n                if (isMovingUp) {\r\n                    entitySize = parentNs.left - entityNs.right;\r\n                } else {\r\n                    entitySize = parentNs.right - entityNs.left;\r\n                }\r\n\r\n                // Moved entity logic\r\n                const updateLeftSide =\r\n                    `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\r\n                        `${leftColumnName} < ${entityNs.right} ` +\r\n                    `THEN ${leftColumnName} + ${entitySize} `;\r\n\r\n                const updateRightSide =\r\n                    `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\r\n                        `${rightColumnName} <= ${entityNs.right} ` +\r\n                    `THEN ${rightColumnName} + ${entitySize} `;\r\n\r\n                // Update the surrounding entities\r\n                if (isMovingUp) {\r\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\r\n                        `SET ${leftColumnName} = CASE ` +\r\n                            `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\r\n                                `${leftColumnName} <= ${parentNs.left} ` +\r\n                            `THEN ${leftColumnName} - ${treeSize} ` +\r\n                            updateLeftSide +\r\n                            `ELSE ${leftColumnName} ` +\r\n                        `END, ` +\r\n                        `${rightColumnName} = CASE ` +\r\n                            `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\r\n                                `${rightColumnName} < ${parentNs.left} ` +\r\n                            `THEN ${rightColumnName} - ${treeSize} ` +\r\n                            updateRightSide +\r\n                            `ELSE ${rightColumnName} ` +\r\n                        `END`);\r\n                } else {\r\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\r\n                        `SET ${leftColumnName} = CASE ` +\r\n                            `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\r\n                                `${leftColumnName} > ${parentNs.right} ` +\r\n                            `THEN ${leftColumnName} + ${treeSize} ` +\r\n                            updateLeftSide +\r\n                            `ELSE ${leftColumnName} ` +\r\n                        `END, ` +\r\n                        `${rightColumnName} = CASE ` +\r\n                            `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\r\n                                `${rightColumnName} >= ${parentNs.right} ` +\r\n                            `THEN ${rightColumnName} + ${treeSize} ` +\r\n                            updateRightSide +\r\n                            `ELSE ${rightColumnName} ` +\r\n                        `END`);\r\n                }\r\n            }\r\n        } else {\r\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\r\n\r\n            // Validate if a root entity already exits and throw an exception\r\n            if (!isUniqueRoot)\r\n                throw new NestedSetMultipleRootError();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Executes operations when subject is being removed.\r\n    */\r\n    async remove(subjects: Subject|Subject[]): Promise<void> {\r\n        if (!Array.isArray(subjects))\r\n            subjects = [subjects];\r\n\r\n        const metadata = subjects[0].metadata;\r\n\r\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\r\n        const tableName = this.getTableName(metadata.tablePath);\r\n        const leftColumnName = escape(metadata.nestedSetLeftColumn!.databaseName);\r\n        const rightColumnName = escape(metadata.nestedSetRightColumn!.databaseName);\r\n\r\n        let entitiesIds: ObjectLiteral[] = [];\r\n        for (const subject of subjects) {\r\n            const entityId = metadata.getEntityIdMap(subject.entity);\r\n\r\n            if (entityId) {\r\n                entitiesIds.push(entityId);\r\n            }\r\n        }\r\n\r\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);\r\n\r\n        for (const entity of entitiesNs) {\r\n            const treeSize = entity.right - entity.left + 1;\r\n\r\n            await this.queryRunner.query(`UPDATE ${tableName} ` +\r\n                `SET ${leftColumnName} = CASE ` +\r\n                    `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\r\n                    `ELSE ${leftColumnName} ` +\r\n                `END, ` +\r\n                `${rightColumnName} = CASE ` +\r\n                    `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\r\n                    `ELSE ${rightColumnName} ` +\r\n                `END`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the nested set ids for a given entity\r\n     */\r\n    protected getNestedSetIds(metadata: EntityMetadata, ids: ObjectLiteral | ObjectLiteral[]): Promise<NestedSetIds[]> {\r\n        const select = {\r\n            left: `${metadata.targetName}.${metadata.nestedSetLeftColumn!.propertyPath}`,\r\n            right: `${metadata.targetName}.${metadata.nestedSetRightColumn!.propertyPath}`\r\n        };\r\n\r\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder();\r\n\r\n        Object.entries(select).forEach(([key, value]) => {\r\n            queryBuilder.addSelect(value, key);\r\n        });\r\n\r\n        return queryBuilder\r\n            .from(metadata.target, metadata.targetName)\r\n            .whereInIds(ids)\r\n            .orderBy(select.right, \"DESC\")\r\n            .getRawMany()\r\n            .then(results => {\r\n                const data: NestedSetIds[] = [];\r\n\r\n                for (const result of results) {\r\n                    const entry: any = {};\r\n                    for (const key of Object.keys(select)) {\r\n                        const value = result ? result[key] : undefined;\r\n\r\n                        // CockroachDB returns numeric types as string\r\n                        entry[key] = typeof value === \"string\" ? parseInt(value) : value;\r\n                    }\r\n                    data.push(entry);\r\n                }\r\n\r\n                return data;\r\n            });\r\n    }\r\n\r\n    private async isUniqueRootEntity(subject: Subject, parent: any): Promise<boolean> {\r\n        const escape = (alias: string) => this.queryRunner.connection.driver.escape(alias);\r\n        const tableName = this.getTableName(subject.metadata.tablePath);\r\n        const parameters: any[] = [];\r\n        const whereCondition = subject.metadata.treeParentRelation!.joinColumns.map(column => {\r\n            const columnName = escape(column.databaseName);\r\n            const parameter = column.getEntityValue(parent);\r\n\r\n            if (parameter == null) {\r\n                return `${columnName} IS NULL`;\r\n            }\r\n\r\n            parameters.push(parameter);\r\n            const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\r\n            return `${columnName} = ${parameterName}`;\r\n        }).join(\" AND \");\r\n\r\n        const countAlias = \"count\";\r\n        const result = await this.queryRunner.query(\r\n            `SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`,\r\n            parameters,\r\n            true\r\n        );\r\n\r\n        return parseInt(result.records[0][countAlias]) === 0;\r\n    }\r\n\r\n    /**\r\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\r\n     * schema name, otherwise returns escaped table name.\r\n     */\r\n    protected getTableName(tablePath: string): string {\r\n        return tablePath.split(\".\")\r\n            .map(i => {\r\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\r\n                return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\r\n            }).join(\".\");\r\n    }\r\n}\r\n"],"sourceRoot":"../.."}