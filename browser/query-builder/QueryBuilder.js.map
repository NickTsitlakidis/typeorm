{"version":3,"sources":["../browser/src/query-builder/QueryBuilder.ts"],"names":[],"mappings":"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","file":"QueryBuilder.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\r\nimport {SelectQueryBuilder} from \"./SelectQueryBuilder\";\r\nimport {UpdateQueryBuilder} from \"./UpdateQueryBuilder\";\r\nimport {DeleteQueryBuilder} from \"./DeleteQueryBuilder\";\r\nimport {SoftDeleteQueryBuilder} from \"./SoftDeleteQueryBuilder\";\r\nimport {InsertQueryBuilder} from \"./InsertQueryBuilder\";\r\nimport {RelationQueryBuilder} from \"./RelationQueryBuilder\";\r\nimport {EntityTarget} from \"../common/EntityTarget\";\r\nimport {Alias} from \"./Alias\";\r\nimport {Brackets} from \"./Brackets\";\r\nimport {QueryDeepPartialEntity} from \"./QueryPartialEntity\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\r\nimport {CockroachDriver} from \"../driver/cockroachdb/CockroachDriver\";\r\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\r\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\r\nimport {EntitySchema} from \"../entity-schema/EntitySchema\";\r\nimport {FindOperator} from \"../find-options/FindOperator\";\r\nimport {In} from \"../find-options/operator/In\";\r\nimport {EntityColumnNotFound} from \"../error/EntityColumnNotFound\";\r\nimport {TypeORMError} from \"../error\";\r\nimport {WhereClause, WhereClauseCondition} from \"./WhereClause\";\r\nimport {NotBrackets} from \"./NotBrackets\";\r\nimport {ReturningType} from \"../driver/Driver\";\r\n\r\n// todo: completely cover query builder with tests\r\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\r\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\r\n// todo: fix problem with long aliases eg getMaxIdentifierLength\r\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\r\n// todo: implement joinAlways in relations and relationId\r\n// todo: finish partial selection\r\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\r\n// todo: implement @Select decorator\r\n// todo: add select and map functions\r\n\r\n// todo: implement relation/entity loading and setting them into properties within a separate query\r\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\r\n// .loadAndMap(\"post.categories\", Category, qb => ...)\r\n\r\n/**\r\n * Allows to build complex sql queries in a fashion way and execute those queries.\r\n */\r\nexport abstract class QueryBuilder<Entity> {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Connection on which QueryBuilder was created.\r\n     */\r\n    readonly connection: Connection;\r\n\r\n    /**\r\n     * Contains all properties of the QueryBuilder that needs to be build a final query.\r\n     */\r\n    readonly expressionMap: QueryExpressionMap;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Query runner used to execute query builder query.\r\n     */\r\n    protected queryRunner?: QueryRunner;\r\n\r\n    /**\r\n     * If QueryBuilder was created in a subquery mode then its parent QueryBuilder (who created subquery) will be stored here.\r\n     */\r\n    protected parentQueryBuilder: QueryBuilder<any>;\r\n\r\n    /**\r\n     * Memo to help keep place of current parameter index for `createParameter`\r\n     */\r\n    private parameterIndex = 0;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\r\n     */\r\n    constructor(queryBuilder: QueryBuilder<any>);\r\n\r\n    /**\r\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\r\n     */\r\n    constructor(connection: Connection, queryRunner?: QueryRunner);\r\n\r\n    /**\r\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\r\n     */\r\n    constructor(connectionOrQueryBuilder: Connection|QueryBuilder<any>, queryRunner?: QueryRunner) {\r\n        if (connectionOrQueryBuilder instanceof QueryBuilder) {\r\n            this.connection = connectionOrQueryBuilder.connection;\r\n            this.queryRunner = connectionOrQueryBuilder.queryRunner;\r\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\r\n\r\n        } else {\r\n            this.connection = connectionOrQueryBuilder;\r\n            this.queryRunner = queryRunner;\r\n            this.expressionMap = new QueryExpressionMap(this.connection);\r\n        }\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Abstract Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets generated SQL query without parameters being replaced.\r\n     */\r\n    abstract getQuery(): string;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Accessors\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets the main alias string used in this query builder.\r\n     */\r\n    get alias(): string {\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new TypeORMError(`Main alias is not set`); // todo: better exception\r\n\r\n        return this.expressionMap.mainAlias.name;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates SELECT query.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(): SelectQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string, selectionAliasName?: string): SelectQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection: string[]): SelectQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates SELECT query and selects given data.\r\n     * Replaces all previous selections if they exist.\r\n     */\r\n    select(selection?: string|string[], selectionAliasName?: string): SelectQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"select\";\r\n        if (Array.isArray(selection)) {\r\n            this.expressionMap.selects = selection.map(selection => ({ selection: selection }));\r\n        } else if (selection) {\r\n            this.expressionMap.selects = [{ selection: selection, aliasName: selectionAliasName }];\r\n        }\r\n\r\n        // loading it dynamically because of circular issue\r\n        const SelectQueryBuilderCls = require(\"./SelectQueryBuilder\").SelectQueryBuilder;\r\n        if (this instanceof SelectQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new SelectQueryBuilderCls(this);\r\n    }\r\n\r\n    /**\r\n     * Creates INSERT query.\r\n     */\r\n    insert(): InsertQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"insert\";\r\n\r\n        // loading it dynamically because of circular issue\r\n        const InsertQueryBuilderCls = require(\"./InsertQueryBuilder\").InsertQueryBuilder;\r\n        if (this instanceof InsertQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new InsertQueryBuilderCls(this);\r\n    }\r\n\r\n    /**\r\n     * Creates UPDATE query and applies given update values.\r\n     */\r\n    update(): UpdateQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates UPDATE query and applies given update values.\r\n     */\r\n    update(updateSet: QueryDeepPartialEntity<Entity>): UpdateQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates UPDATE query for the given entity and applies given update values.\r\n     */\r\n    update<Entity>(entity: EntityTarget<Entity>, updateSet?: QueryDeepPartialEntity<Entity>): UpdateQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates UPDATE query for the given table name and applies given update values.\r\n     */\r\n    update(tableName: string, updateSet?: QueryDeepPartialEntity<Entity>): UpdateQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Creates UPDATE query and applies given update values.\r\n     */\r\n    update(entityOrTableNameUpdateSet?: EntityTarget<any>|ObjectLiteral, maybeUpdateSet?: ObjectLiteral): UpdateQueryBuilder<any> {\r\n        const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet as ObjectLiteral|undefined;\r\n        entityOrTableNameUpdateSet = entityOrTableNameUpdateSet instanceof EntitySchema ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;\r\n\r\n        if (entityOrTableNameUpdateSet instanceof Function || typeof entityOrTableNameUpdateSet === \"string\") {\r\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\r\n            this.expressionMap.setMainAlias(mainAlias);\r\n        }\r\n\r\n        this.expressionMap.queryType = \"update\";\r\n        this.expressionMap.valuesSet = updateSet;\r\n\r\n        // loading it dynamically because of circular issue\r\n        const UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\").UpdateQueryBuilder;\r\n        if (this instanceof UpdateQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new UpdateQueryBuilderCls(this);\r\n    }\r\n\r\n    /**\r\n     * Creates DELETE query.\r\n     */\r\n    delete(): DeleteQueryBuilder<Entity> {\r\n        this.expressionMap.queryType = \"delete\";\r\n\r\n        // loading it dynamically because of circular issue\r\n        const DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\").DeleteQueryBuilder;\r\n        if (this instanceof DeleteQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new DeleteQueryBuilderCls(this);\r\n    }\r\n\r\n    softDelete(): SoftDeleteQueryBuilder<any> {\r\n        this.expressionMap.queryType = \"soft-delete\";\r\n\r\n        // loading it dynamically because of circular issue\r\n        const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\r\n        if (this instanceof SoftDeleteQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new SoftDeleteQueryBuilderCls(this);\r\n    }\r\n\r\n    restore(): SoftDeleteQueryBuilder<any> {\r\n        this.expressionMap.queryType = \"restore\";\r\n\r\n        // loading it dynamically because of circular issue\r\n        const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\r\n        if (this instanceof SoftDeleteQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new SoftDeleteQueryBuilderCls(this);\r\n    }\r\n\r\n    /**\r\n     * Sets entity's relation with which this query builder gonna work.\r\n     */\r\n    relation(propertyPath: string): RelationQueryBuilder<Entity>;\r\n\r\n    /**\r\n     * Sets entity's relation with which this query builder gonna work.\r\n     */\r\n    relation<T>(entityTarget: EntityTarget<T>, propertyPath: string): RelationQueryBuilder<T>;\r\n\r\n    /**\r\n     * Sets entity's relation with which this query builder gonna work.\r\n     */\r\n    relation(entityTargetOrPropertyPath: Function|string, maybePropertyPath?: string): RelationQueryBuilder<Entity> {\r\n        const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\r\n        const propertyPath = arguments.length === 2 ? maybePropertyPath as string : entityTargetOrPropertyPath as string;\r\n\r\n        this.expressionMap.queryType = \"relation\";\r\n        this.expressionMap.relationPropertyPath = propertyPath;\r\n\r\n        if (entityTarget) {\r\n            const mainAlias = this.createFromAlias(entityTarget);\r\n            this.expressionMap.setMainAlias(mainAlias);\r\n        }\r\n\r\n        // loading it dynamically because of circular issue\r\n        const RelationQueryBuilderCls = require(\"./RelationQueryBuilder\").RelationQueryBuilder;\r\n        if (this instanceof RelationQueryBuilderCls)\r\n            return this as any;\r\n\r\n        return new RelationQueryBuilderCls(this);\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks if given relation exists in the entity.\r\n     * Returns true if relation exists, false otherwise.\r\n     *\r\n     * todo: move this method to manager? or create a shortcut?\r\n     */\r\n    hasRelation<T>(target: EntityTarget<T>, relation: string): boolean;\r\n\r\n    /**\r\n     * Checks if given relations exist in the entity.\r\n     * Returns true if relation exists, false otherwise.\r\n     *\r\n     * todo: move this method to manager? or create a shortcut?\r\n     */\r\n    hasRelation<T>(target: EntityTarget<T>, relation: string[]): boolean;\r\n\r\n    /**\r\n     * Checks if given relation or relations exist in the entity.\r\n     * Returns true if relation exists, false otherwise.\r\n     *\r\n     * todo: move this method to manager? or create a shortcut?\r\n     */\r\n    hasRelation<T>(target: EntityTarget<T>, relation: string|string[]): boolean {\r\n        const entityMetadata = this.connection.getMetadata(target);\r\n        const relations = Array.isArray(relation) ? relation : [relation];\r\n        return relations.every(relation => {\r\n            return !!entityMetadata.findRelationWithPropertyPath(relation);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check the existence of a parameter for this query builder.\r\n     */\r\n    hasParameter(key: string): boolean {\r\n        return this.parentQueryBuilder?.hasParameter(key) || key in this.expressionMap.parameters;\r\n    }\r\n\r\n    /**\r\n     * Sets parameter name and its value.\r\n     *\r\n     * The key for this parametere may contain numbers, letters, underscores, or periods.\r\n     */\r\n    setParameter(key: string, value: any): this {\r\n        if (value instanceof Function) {\r\n            throw new TypeORMError(`Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`);\r\n        }\r\n\r\n        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\r\n            throw new TypeORMError(\"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\");\r\n        }\r\n\r\n        if (this.parentQueryBuilder) {\r\n            this.parentQueryBuilder.setParameter(key, value);\r\n        }\r\n\r\n        this.expressionMap.parameters[key] = value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds all parameters from the given object.\r\n     */\r\n    setParameters(parameters: ObjectLiteral): this {\r\n        for (const [key, value] of Object.entries(parameters)) {\r\n            this.setParameter(key, value);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    protected createParameter(value: any): string {\r\n        let parameterName;\r\n\r\n        do {\r\n            parameterName = `orm_param_${this.parameterIndex++}`;\r\n        } while (this.hasParameter(parameterName));\r\n\r\n        this.setParameter(parameterName, value);\r\n\r\n        return `:${parameterName}`;\r\n    }\r\n\r\n    /**\r\n     * Adds native parameters from the given object.\r\n     *\r\n     * @deprecated Use `setParameters` instead\r\n     */\r\n    setNativeParameters(parameters: ObjectLiteral): this {\r\n\r\n        // set parent query builder parameters as well in sub-query mode\r\n        if (this.parentQueryBuilder) {\r\n            this.parentQueryBuilder.setNativeParameters(parameters);\r\n        }\r\n\r\n        Object.keys(parameters).forEach(key => {\r\n            this.expressionMap.nativeParameters[key] = parameters[key];\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets all parameters.\r\n     */\r\n    getParameters(): ObjectLiteral {\r\n        const parameters: ObjectLiteral = Object.assign({}, this.expressionMap.parameters);\r\n\r\n        // add discriminator column parameter if it exist\r\n        if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata;\r\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\r\n                const values = metadata.childEntityMetadatas\r\n                    .filter(childMetadata => childMetadata.discriminatorColumn)\r\n                    .map(childMetadata => childMetadata.discriminatorValue);\r\n                values.push(metadata.discriminatorValue);\r\n                parameters[\"discriminatorColumnValues\"] = values;\r\n            }\r\n        }\r\n\r\n        return parameters;\r\n    }\r\n\r\n    /**\r\n     * Prints sql to stdout using console.log.\r\n     */\r\n    printSql(): this { // TODO rename to logSql()\r\n        const [query, parameters] = this.getQueryAndParameters();\r\n        this.connection.logger.logQuery(query, parameters);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Gets generated sql that will be executed.\r\n     * Parameters in the query are escaped for the currently used driver.\r\n     */\r\n    getSql(): string {\r\n        return this.getQueryAndParameters()[0];\r\n    }\r\n\r\n    /**\r\n     * Gets query to be executed with all parameters used in it.\r\n     */\r\n    getQueryAndParameters(): [string, any[]] {\r\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\r\n        const query = this.getQuery();\r\n        const parameters = this.getParameters();\r\n        return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\r\n    }\r\n\r\n    /**\r\n     * Executes sql generated by query builder and returns raw database results.\r\n     */\r\n    async execute(): Promise<any> {\r\n        const [sql, parameters] = this.getQueryAndParameters();\r\n        const queryRunner = this.obtainQueryRunner();\r\n        try {\r\n            return await queryRunner.query(sql, parameters);  // await is needed here because we are using finally\r\n        } finally {\r\n            if (queryRunner !== this.queryRunner) { // means we created our own query runner\r\n                await queryRunner.release();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a completely new query builder.\r\n     * Uses same query runner as current QueryBuilder.\r\n     */\r\n    createQueryBuilder(): this {\r\n        return new (this.constructor as any)(this.connection, this.queryRunner);\r\n    }\r\n\r\n    /**\r\n     * Clones query builder as it is.\r\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\r\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\r\n     * where queryBuilder is cloned QueryBuilder.\r\n     */\r\n    clone(): this {\r\n        return new (this.constructor as any)(this);\r\n    }\r\n\r\n    /**\r\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\r\n     * such as finding a specific query in the database server's logs, or for categorization using\r\n     * an APM product.\r\n     */\r\n    comment(comment: string): this {\r\n        this.expressionMap.comment = comment;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Disables escaping.\r\n     */\r\n    disableEscaping(): this {\r\n        this.expressionMap.disableEscaping = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Escapes table name, column name or alias name using current database's escaping character.\r\n     */\r\n    escape(name: string): string {\r\n        if (!this.expressionMap.disableEscaping)\r\n            return name;\r\n        return this.connection.driver.escape(name);\r\n    }\r\n\r\n    /**\r\n     * Sets or overrides query builder's QueryRunner.\r\n     */\r\n    setQueryRunner(queryRunner: QueryRunner): this {\r\n        this.queryRunner = queryRunner;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Indicates if listeners and subscribers must be called before and after query execution.\r\n     * Enabled by default.\r\n     */\r\n    callListeners(enabled: boolean): this {\r\n        this.expressionMap.callListeners = enabled;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * If set to true the query will be wrapped into a transaction.\r\n     */\r\n    useTransaction(enabled: boolean): this {\r\n        this.expressionMap.useTransaction = enabled;\r\n        return this;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Gets escaped table name with schema name if SqlServer driver used with custom\r\n     * schema name, otherwise returns escaped table name.\r\n     */\r\n    protected getTableName(tablePath: string): string {\r\n        return tablePath.split(\".\")\r\n            .map(i => {\r\n                // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\r\n                if (i === \"\")\r\n                    return i;\r\n                return this.escape(i);\r\n            }).join(\".\");\r\n    }\r\n\r\n    /**\r\n     * Gets name of the table where insert should be performed.\r\n     */\r\n    protected getMainTableName(): string {\r\n        if (!this.expressionMap.mainAlias)\r\n            throw new TypeORMError(`Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`);\r\n\r\n        if (this.expressionMap.mainAlias.hasMetadata)\r\n            return this.expressionMap.mainAlias.metadata.tablePath;\r\n\r\n        return this.expressionMap.mainAlias.tablePath!;\r\n    }\r\n\r\n    /**\r\n     * Specifies FROM which entity's table select/update/delete will be executed.\r\n     * Also sets a main string alias of the selection data.\r\n     */\r\n    protected createFromAlias(entityTarget: EntityTarget<any>|((qb: SelectQueryBuilder<any>) => SelectQueryBuilder<any>), aliasName?: string): Alias {\r\n\r\n        // if table has a metadata then find it to properly escape its properties\r\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\r\n        if (this.connection.hasMetadata(entityTarget)) {\r\n            const metadata = this.connection.getMetadata(entityTarget);\r\n\r\n            return this.expressionMap.createAlias({\r\n                type: \"from\",\r\n                name: aliasName,\r\n                metadata: this.connection.getMetadata(entityTarget),\r\n                tablePath: metadata.tablePath\r\n            });\r\n\r\n        } else {\r\n            if (typeof entityTarget === \"string\") {\r\n                const isSubquery = entityTarget.substr(0, 1) === \"(\" && entityTarget.substr(-1) === \")\";\r\n\r\n                return this.expressionMap.createAlias({\r\n                    type: \"from\",\r\n                    name: aliasName,\r\n                    tablePath: !isSubquery ? entityTarget as string : undefined,\r\n                    subQuery: isSubquery ? entityTarget : undefined,\r\n                });\r\n            }\r\n\r\n            const subQueryBuilder: SelectQueryBuilder<any> = (entityTarget as any)(((this as any) as SelectQueryBuilder<any>).subQuery());\r\n            this.setParameters(subQueryBuilder.getParameters());\r\n            const subquery = subQueryBuilder.getQuery();\r\n\r\n            return this.expressionMap.createAlias({\r\n                type: \"from\",\r\n                name: aliasName,\r\n                subQuery: subquery\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replaces all entity's propertyName to name in the given statement.\r\n     */\r\n    protected replacePropertyNames(statement: string) {\r\n        // Escape special characters in regular expressions\r\n        // Per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\r\n        const escapeRegExp = (s: String) => s.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n\r\n        for (const alias of this.expressionMap.aliases) {\r\n            if (!alias.hasMetadata) continue;\r\n            const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.` : \"\";\r\n            const replacementAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled ? `${this.escape(alias.name)}.` : \"\";\r\n\r\n            const replacements: { [key: string]: string } = {};\r\n\r\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\r\n            // To do this we iterate and overwrite in the order of relevance.\r\n            // Least to Most Relevant:\r\n            // * Relation Property Path to first join column key\r\n            // * Relation Property Path + Column Path\r\n            // * Column Database Name\r\n            // * Column Propety Name\r\n            // * Column Property Path\r\n\r\n            for (const relation of alias.metadata.relations) {\r\n                if (relation.joinColumns.length > 0)\r\n                    replacements[relation.propertyPath] = relation.joinColumns[0].databaseName;\r\n            }\r\n\r\n            for (const relation of alias.metadata.relations) {\r\n                for (const joinColumn of [...relation.joinColumns, ...relation.inverseJoinColumns]) {\r\n                    const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn!.propertyPath}`;\r\n                    replacements[propertyKey] = joinColumn.databaseName;\r\n                }\r\n            }\r\n\r\n            for (const column of alias.metadata.columns) {\r\n                replacements[column.databaseName] = column.databaseName;\r\n            }\r\n\r\n            for (const column of alias.metadata.columns) {\r\n                replacements[column.propertyName] = column.databaseName;\r\n            }\r\n\r\n            for (const column of alias.metadata.columns) {\r\n                replacements[column.propertyPath] = column.databaseName;\r\n            }\r\n\r\n            const replacementKeys = Object.keys(replacements);\r\n\r\n            if (replacementKeys.length) {\r\n                statement = statement.replace(new RegExp(\r\n                    // Avoid a lookbehind here since it's not well supported\r\n                    `([ =\\(]|^.{0})` +\r\n                    `${escapeRegExp(replaceAliasNamePrefix)}(${replacementKeys.map(escapeRegExp).join(\"|\")})` +\r\n                    `(?=[ =\\)\\,]|.{0}$)`,\r\n                    \"gm\"\r\n                ), (_, pre, p) =>\r\n                    `${pre}${replacementAliasNamePrefix}${this.escape(replacements[p])}`\r\n                );\r\n            }\r\n        }\r\n\r\n        return statement;\r\n    }\r\n\r\n    protected createComment(): string {\r\n        if (!this.expressionMap.comment) {\r\n            return \"\";\r\n        }\r\n\r\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\r\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\r\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\r\n        // as-is and it should be valid.\r\n\r\n        return `/* ${this.expressionMap.comment.replace(\"*/\", \"\")} */ `;\r\n    }\r\n\r\n    /**\r\n     * Creates \"WHERE\" expression.\r\n     */\r\n    protected createWhereExpression() {\r\n        const conditionsArray = [];\r\n\r\n        const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);\r\n\r\n        if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\r\n            conditionsArray.push(this.replacePropertyNames(whereExpression));\r\n        }\r\n\r\n        if (this.expressionMap.mainAlias!.hasMetadata) {\r\n            const metadata = this.expressionMap.mainAlias!.metadata;\r\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\r\n            if (this.expressionMap.queryType === \"select\" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {\r\n                const column = this.expressionMap.aliasNamePrefixingEnabled\r\n                    ? this.expressionMap.mainAlias!.name + \".\" + metadata.deleteDateColumn.propertyName\r\n                    : metadata.deleteDateColumn.propertyName;\r\n\r\n                const condition = `${this.replacePropertyNames(column)} IS NULL`;\r\n                conditionsArray.push(condition);\r\n            }\r\n\r\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\r\n                const column = this.expressionMap.aliasNamePrefixingEnabled\r\n                    ? this.expressionMap.mainAlias!.name + \".\" + metadata.discriminatorColumn.databaseName\r\n                    : metadata.discriminatorColumn.databaseName;\r\n\r\n                const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;\r\n                conditionsArray.push(condition);\r\n            }\r\n        }\r\n\r\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\r\n            const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\r\n            conditionsArray.push(condition);\r\n        }\r\n\r\n        if (!conditionsArray.length) {\r\n            return \"\";\r\n        } else if (conditionsArray.length === 1) {\r\n            return ` WHERE ${conditionsArray[0]}`;\r\n        } else {\r\n            return ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\r\n     */\r\n    protected createReturningExpression(returningType: ReturningType): string {\r\n        const columns = this.getReturningColumns();\r\n        const driver = this.connection.driver;\r\n\r\n        // also add columns we must auto-return to perform entity updation\r\n        // if user gave his own returning\r\n        if (typeof this.expressionMap.returning !== \"string\" &&\r\n            this.expressionMap.extraReturningColumns.length > 0 &&\r\n            driver.isReturningSqlSupported(returningType)) {\r\n            columns.push(...this.expressionMap.extraReturningColumns.filter(column => {\r\n                return columns.indexOf(column) === -1;\r\n            }));\r\n        }\r\n\r\n        if (columns.length) {\r\n            let columnsExpression = columns.map(column => {\r\n                const name = this.escape(column.databaseName);\r\n                if (driver instanceof SqlServerDriver) {\r\n                    if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\" || this.expressionMap.queryType === \"soft-delete\" || this.expressionMap.queryType === \"restore\") {\r\n                        return \"INSERTED.\" + name;\r\n                    } else {\r\n                        return this.escape(this.getMainTableName()) + \".\" + name;\r\n                    }\r\n                } else {\r\n                    return name;\r\n                }\r\n            }).join(\", \");\r\n\r\n            if (driver instanceof OracleDriver) {\r\n                columnsExpression += \" INTO \" + columns.map(column => {\r\n                    return this.createParameter({ type: driver.columnTypeToNativeParameter(column.type), dir: driver.oracle.BIND_OUT });\r\n                }).join(\", \");\r\n            }\r\n\r\n            if (driver instanceof SqlServerDriver) {\r\n                if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\") {\r\n                    columnsExpression += \" INTO @OutputTable\";\r\n                }\r\n            }\r\n\r\n            return columnsExpression;\r\n\r\n        } else if (typeof this.expressionMap.returning === \"string\") {\r\n            return this.expressionMap.returning;\r\n        }\r\n\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * If returning / output cause is set to array of column names,\r\n     * then this method will return all column metadatas of those column names.\r\n     */\r\n    protected getReturningColumns(): ColumnMetadata[] {\r\n        const columns: ColumnMetadata[] = [];\r\n        if (Array.isArray(this.expressionMap.returning)) {\r\n            (this.expressionMap.returning as string[]).forEach(columnName => {\r\n                if (this.expressionMap.mainAlias!.hasMetadata) {\r\n                    columns.push(...this.expressionMap.mainAlias!.metadata.findColumnsWithPropertyPath(columnName));\r\n                }\r\n            });\r\n        }\r\n        return columns;\r\n    }\r\n\r\n    protected createWhereClausesExpression(clauses: WhereClause[]): string {\r\n        return clauses.map((clause, index) => {\r\n            const expression = this.createWhereConditionExpression(clause.condition);\r\n\r\n            switch (clause.type) {\r\n                case \"and\":\r\n                    return (index > 0 ? \"AND \" : \"\") + expression;\r\n                case \"or\":\r\n                    return (index > 0 ? \"OR \" : \"\") + expression;\r\n            }\r\n\r\n            return expression;\r\n        }).join(\" \").trim();\r\n    }\r\n\r\n    /**\r\n     * Computes given where argument - transforms to a where string all forms it can take.\r\n     */\r\n    protected createWhereConditionExpression(condition: WhereClauseCondition, alwaysWrap: boolean = false): string {\r\n        if (typeof condition === \"string\")\r\n            return condition;\r\n\r\n        if (Array.isArray(condition)) {\r\n            if (condition.length === 0) {\r\n                return \"1=1\";\r\n            }\r\n\r\n            // In the future we should probably remove this entire condition\r\n            // but for now to prevent any breaking changes it exists.\r\n            if (condition.length === 1 && !alwaysWrap) {\r\n                return this.createWhereClausesExpression(condition);\r\n            }\r\n\r\n            return \"(\" + this.createWhereClausesExpression(condition) + \")\";\r\n        }\r\n\r\n        const { driver } = this.connection;\r\n\r\n        switch (condition.operator) {\r\n            case \"lessThan\":\r\n                return `${condition.parameters[0]} < ${condition.parameters[1]}`;\r\n            case \"lessThanOrEqual\":\r\n                return `${condition.parameters[0]} <= ${condition.parameters[1]}`;\r\n            case \"moreThan\":\r\n                return `${condition.parameters[0]} > ${condition.parameters[1]}`;\r\n            case \"moreThanOrEqual\":\r\n                return `${condition.parameters[0]} >= ${condition.parameters[1]}`;\r\n            case \"notEqual\":\r\n                return `${condition.parameters[0]} != ${condition.parameters[1]}`;\r\n            case \"equal\":\r\n                return `${condition.parameters[0]} = ${condition.parameters[1]}`;\r\n            case \"ilike\":\r\n                if (driver instanceof PostgresDriver || driver instanceof CockroachDriver) {\r\n                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;\r\n                }\r\n\r\n                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;\r\n            case \"like\":\r\n                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;\r\n            case \"between\":\r\n                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;\r\n            case \"in\":\r\n                if (condition.parameters.length <= 1) {\r\n                    return \"0=1\";\r\n                }\r\n                return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(\", \")})`;\r\n            case \"any\":\r\n                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;\r\n            case \"isNull\":\r\n                return `${condition.parameters[0]} IS NULL`;\r\n\r\n            case \"not\":\r\n                return `NOT(${this.createWhereConditionExpression(condition.condition)})`;\r\n            case \"brackets\":\r\n                return `${this.createWhereConditionExpression(condition.condition, true)}`;\r\n        }\r\n\r\n        throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Creates \"WHERE\" condition for an in-ids condition.\r\n     */\r\n    protected getWhereInIdsCondition(ids: any|any[]): ObjectLiteral | Brackets  {\r\n        const metadata = this.expressionMap.mainAlias!.metadata;\r\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map(id => metadata.ensureEntityIdMap(id));\r\n\r\n        // using in(...ids) for single primary key entities\r\n        if (!metadata.hasMultiplePrimaryKeys) {\r\n            const primaryColumn = metadata.primaryColumns[0];\r\n\r\n            // getEntityValue will try to transform `In`, it is a bug\r\n            // todo: remove this transformer check after #2390 is fixed\r\n            // This also fails for embedded & relation, so until that is fixed skip it.\r\n            if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {\r\n                return {\r\n                    [primaryColumn.propertyName]: In(\r\n                        normalized.map(id => primaryColumn.getEntityValue(id, false))\r\n                    )\r\n                };\r\n            }\r\n        }\r\n\r\n        return new Brackets((qb) => {\r\n            for (const data of normalized) {\r\n                qb.orWhere(new Brackets(\r\n                    (qb) => qb.where(data)\r\n                ));\r\n            }\r\n        });\r\n    }\r\n\r\n    private findColumnsForPropertyPath(propertyPath: string): [ Alias, string[], ColumnMetadata[] ] {\r\n        // Make a helper to iterate the entity & relations?\r\n        // Use that to set the correct alias?  Or the other way around?\r\n\r\n        // Start with the main alias with our property paths\r\n        let alias = this.expressionMap.mainAlias;\r\n        const root: string[] = [];\r\n        const propertyPathParts = propertyPath.split(\".\");\r\n\r\n        while (propertyPathParts.length > 1) {\r\n            const part = propertyPathParts[0];\r\n\r\n            if (!alias?.hasMetadata) {\r\n                // If there's no metadata, we're wasting our time\r\n                // and can't actually look any of this up.\r\n                break;\r\n            }\r\n\r\n            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\r\n                // If this is an embedded then we should combine the two as part of our lookup.\r\n                // Instead of just breaking, we keep going with this in case there's an embedded/relation\r\n                // inside an embedded.\r\n                propertyPathParts.unshift(\r\n                    `${propertyPathParts.shift()}.${propertyPathParts.shift()}`\r\n                );\r\n                continue;\r\n            }\r\n\r\n            if (alias.metadata.hasRelationWithPropertyPath(part)) {\r\n                // If this is a relation then we should find the aliases\r\n                // that match the relation & then continue further down\r\n                // the property path\r\n                const joinAttr = this.expressionMap.joinAttributes.find(\r\n                    (joinAttr) => joinAttr.relationPropertyPath === part\r\n                );\r\n\r\n                if (!joinAttr?.alias) {\r\n                    const fullRelationPath = root.length > 0 ? `${root.join(\".\")}.${part}` : part;\r\n                    throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);\r\n                }\r\n\r\n                alias = joinAttr.alias;\r\n                root.push(...part.split(\".\"));\r\n                propertyPathParts.shift();\r\n                continue;\r\n            }\r\n\r\n            break;\r\n        }\r\n\r\n        if (!alias) {\r\n            throw new Error(`Cannot find alias for property ${propertyPath}`);\r\n        }\r\n\r\n        // Remaining parts are combined back and used to find the actual property path\r\n        const aliasPropertyPath = propertyPathParts.join(\".\");\r\n\r\n        const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);\r\n\r\n        if (!columns.length) {\r\n            throw new EntityColumnNotFound(propertyPath);\r\n        }\r\n\r\n        return [ alias, root, columns ];\r\n    }\r\n\r\n    /**\r\n     * Creates a property paths for a given ObjectLiteral.\r\n     */\r\n    protected createPropertyPath(metadata: EntityMetadata, entity: ObjectLiteral, prefix: string = \"\") {\r\n        const paths: string[] = [];\r\n\r\n        for (const key of Object.keys(entity)) {\r\n            const path = prefix ? `${prefix}.${key}` : key;\r\n\r\n            // There's times where we don't actually want to traverse deeper.\r\n            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\r\n            if (entity[key] === null || typeof entity[key] !== \"object\" || entity[key] instanceof FindOperator) {\r\n                paths.push(path);\r\n                continue;\r\n            }\r\n\r\n            if (metadata.hasEmbeddedWithPropertyPath(path)) {\r\n                const subPaths = this.createPropertyPath(metadata, entity[key], path);\r\n                paths.push(...subPaths);\r\n                continue;\r\n            }\r\n\r\n            if (metadata.hasRelationWithPropertyPath(path)) {\r\n                const relation = metadata.findRelationWithPropertyPath(path)!;\r\n\r\n                // There's also cases where we don't want to return back all of the properties.\r\n                // These handles the situation where someone passes the model & we don't need to make\r\n                // a HUGE `where` to uniquely look up the entity.\r\n\r\n                // In the case of a *-to-one, there's only ever one possible entity on the other side\r\n                // so if the join columns are all defined we can return just the relation itself\r\n                // because it will fetch only the join columns and do the lookup.\r\n                if (relation.relationType === \"one-to-one\" || relation.relationType === \"many-to-one\") {\r\n                    const joinColumns = relation.joinColumns\r\n                        .map(j => j.referencedColumn)\r\n                        .filter((j): j is ColumnMetadata => !!j);\r\n\r\n                    const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every(\r\n                        column => column.getEntityValue(entity[key], false)\r\n                    );\r\n\r\n                    if (hasAllJoinColumns) {\r\n                        paths.push(path);\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (relation.relationType === \"one-to-many\" || relation.relationType === \"many-to-many\") {\r\n                    throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);\r\n                }\r\n\r\n                // For any other case, if the `entity[key]` contains all of the primary keys we can do a\r\n                // lookup via these.  We don't need to look up via any other values 'cause these are\r\n                // the unique primary keys.\r\n                // This handles the situation where someone passes the model & we don't need to make\r\n                // a HUGE where.\r\n                const primaryColumns = relation.inverseEntityMetadata.primaryColumns;\r\n                const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every(\r\n                    column => column.getEntityValue(entity[key], false)\r\n                );\r\n\r\n                if (hasAllPrimaryKeys) {\r\n                    const subPaths = primaryColumns.map(\r\n                        column => `${path}.${column.propertyPath}`\r\n                    );\r\n                    paths.push(...subPaths);\r\n                    continue;\r\n                }\r\n\r\n                // If nothing else, just return every property that's being passed to us.\r\n                const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key])\r\n                    .map(p => `${path}.${p}`);\r\n                paths.push(...subPaths);\r\n                continue;\r\n            }\r\n\r\n            paths.push(path);\r\n        }\r\n\r\n        return paths;\r\n    }\r\n\r\n    protected *getPredicates(where: ObjectLiteral) {\r\n        if (this.expressionMap.mainAlias!.hasMetadata) {\r\n            const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias!.metadata, where);\r\n\r\n            for (const propertyPath of propertyPaths) {\r\n                const [ alias, aliasPropertyPath, columns ] = this.findColumnsForPropertyPath(propertyPath);\r\n\r\n                for (const column of columns) {\r\n                    let containedWhere = where;\r\n\r\n                    for (const part of aliasPropertyPath) {\r\n                        if (!containedWhere || !(part in containedWhere)) {\r\n                            containedWhere = {};\r\n                            break;\r\n                        }\r\n\r\n                        containedWhere = containedWhere[part];\r\n                    }\r\n\r\n                    // Use the correct alias & the property path from the column\r\n                    const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ?\r\n                        `${alias.name}.${column.propertyPath}` :\r\n                        column.propertyPath;\r\n\r\n                    const parameterValue = column.getEntityValue(containedWhere, true);\r\n\r\n                    yield [aliasPath, parameterValue];\r\n                }\r\n            }\r\n        } else {\r\n            for (const key of Object.keys(where)) {\r\n                const parameterValue = where[key];\r\n                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;\r\n\r\n                yield [aliasPath, parameterValue];\r\n            }\r\n        }\r\n    }\r\n\r\n    protected getWherePredicateCondition(aliasPath: string, parameterValue: any): WhereClauseCondition {\r\n        if (parameterValue instanceof FindOperator) {\r\n            let parameters: any[] = [];\r\n            if (parameterValue.useParameter) {\r\n                if (parameterValue.objectLiteralParameters) {\r\n                    this.setParameters(parameterValue.objectLiteralParameters);\r\n                } else if (parameterValue.multipleParameters) {\r\n                    for (const v of parameterValue.value) {\r\n                        parameters.push(this.createParameter(v));\r\n                    }\r\n                } else {\r\n                    parameters.push(this.createParameter(parameterValue.value));\r\n                }\r\n            }\r\n\r\n            if (parameterValue.type === \"raw\") {\r\n                if (parameterValue.getSql) {\r\n                    return parameterValue.getSql(aliasPath);\r\n                } else {\r\n                    return {\r\n                        operator: \"equal\",\r\n                        parameters: [\r\n                            aliasPath,\r\n                            parameterValue.value,\r\n                        ]\r\n                    };\r\n                }\r\n            } else if (parameterValue.type === \"not\") {\r\n                if (parameterValue.child) {\r\n                    return {\r\n                        operator: parameterValue.type,\r\n                        condition: this.getWherePredicateCondition(aliasPath, parameterValue.child),\r\n                    };\r\n                } else {\r\n                    return {\r\n                        operator: \"notEqual\",\r\n                        parameters: [\r\n                            aliasPath,\r\n                            ...parameters,\r\n                        ]\r\n                    };\r\n                }\r\n            } else {\r\n                return {\r\n                    operator: parameterValue.type,\r\n                    parameters: [\r\n                        aliasPath,\r\n                        ...parameters,\r\n                    ]\r\n                };\r\n            }\r\n        } else if (parameterValue === null) {\r\n            return {\r\n                operator: \"isNull\",\r\n                parameters: [\r\n                    aliasPath,\r\n                ]\r\n            };\r\n        } else {\r\n            return {\r\n                operator: \"equal\",\r\n                parameters: [\r\n                    aliasPath,\r\n                    this.createParameter(parameterValue),\r\n                ]\r\n            };\r\n        }\r\n    }\r\n\r\n    protected getWhereCondition(where: string|((qb: this) => string)|Brackets|NotBrackets|ObjectLiteral|ObjectLiteral[]): WhereClauseCondition {\r\n        if (typeof where === \"string\") {\r\n            return where;\r\n        }\r\n\r\n        if (where instanceof Brackets) {\r\n            const whereQueryBuilder = this.createQueryBuilder();\r\n\r\n            whereQueryBuilder.parentQueryBuilder = this;\r\n\r\n            whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;\r\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;\r\n            whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;\r\n            whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;\r\n\r\n            whereQueryBuilder.expressionMap.wheres = [];\r\n\r\n            where.whereFactory(whereQueryBuilder as any);\r\n\r\n            return {\r\n                operator: where instanceof NotBrackets ? \"not\" : \"brackets\",\r\n                condition: whereQueryBuilder.expressionMap.wheres\r\n            };\r\n        }\r\n\r\n        if (where instanceof Function) {\r\n            return where(this);\r\n        }\r\n\r\n        const wheres: ObjectLiteral[] = Array.isArray(where) ? where : [where];\r\n        const clauses: WhereClause[] = [];\r\n\r\n        for (const where of wheres) {\r\n            const conditions: WhereClauseCondition = [];\r\n\r\n            // Filter the conditions and set up the parameter values\r\n            for (const [aliasPath, parameterValue] of this.getPredicates(where)) {\r\n                conditions.push({\r\n                    type: \"and\",\r\n                    condition: this.getWherePredicateCondition(aliasPath, parameterValue),\r\n                });\r\n            }\r\n\r\n            clauses.push({ type: \"or\", condition: conditions });\r\n\r\n        }\r\n\r\n        if (clauses.length === 1) {\r\n            return clauses[0].condition;\r\n        }\r\n\r\n        return clauses;\r\n    }\r\n\r\n    /**\r\n     * Creates a query builder used to execute sql queries inside this query builder.\r\n     */\r\n    protected obtainQueryRunner() {\r\n        return this.queryRunner || this.connection.createQueryRunner();\r\n    }\r\n\r\n}\r\n"],"sourceRoot":".."}